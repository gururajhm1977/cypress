"use strict";
/// <reference path="../types/index.d.ts" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const through_1 = __importDefault(require("through"));
const typescript_1 = __importStar(require("typescript"));
const browserify_preprocessor_1 = __importDefault(require("@cypress/browserify-preprocessor"));
const isTestBlock = (name) => (node) => {
    return typescript_1.default.isIdentifier(node.expression) &&
        node.expression.escapedText === name;
};
const isPropertyAccessExpression = (name) => (node) => {
    return node.name.escapedText === name;
};
const isTitle = (node) => {
    return node && (typescript_1.default.isStringLiteral(node) || typescript_1.default.isTemplateExpression(node));
};
const isDescribe = isTestBlock('describe');
const isContext = isTestBlock('context');
const isIt = isTestBlock('it');
const isOnly = isPropertyAccessExpression('only');
const isSkip = isPropertyAccessExpression('skip');
// Convert tags from comma delimitered environment variables to string arrays
const extractTags = (config) => {
    var _a, _b;
    const includeEnvVar = (_a = config.env.CYPRESS_INCLUDE_TAGS) !== null && _a !== void 0 ? _a : process.env.CYPRESS_INCLUDE_TAGS;
    const excludeEnvVar = (_b = config.env.CYPRESS_EXCLUDE_TAGS) !== null && _b !== void 0 ? _b : process.env.CYPRESS_EXCLUDE_TAGS;
    const includeTags = includeEnvVar ? includeEnvVar.split(',') : [];
    const excludeTags = excludeEnvVar ? excludeEnvVar.split(',') : [];
    return {
        includeTags,
        excludeTags,
    };
};
// Use include and exclude tags to determine if current node should be skipped
const calculateSkipChildren = (includeTags, excludeTags, tags) => {
    const includeTest = includeTags.length === 0 || tags.some(tag => includeTags.includes(tag));
    const excludeTest = excludeTags.length > 0 && tags.some(tag => excludeTags.includes(tag));
    return !(includeTest && !excludeTest);
};
// Remove tag argument from node. Return new node, tags list, and whether or not to skip node
const removeTagsFromNode = (node, parentTags, includeTags, excludeTags) => {
    if (!typescript_1.default.isCallExpression(node)) {
        return {
            node,
            tags: parentTags,
            skipNode: false,
        };
    }
    const firstArg = node.arguments[0];
    let nodeTags = [];
    // Extract tags from node
    if (typescript_1.default.isArrayLiteralExpression(firstArg)) {
        nodeTags = firstArg.elements.map((element) => {
            if (typescript_1.default.isStringLiteral(element)) {
                return element.text;
            }
            else if (typescript_1.default.isPropertyAccessExpression(element)) {
                // Return enum's string value, eg. Tag.WIP => "WIP"
                return element.name.escapedText;
            }
            return '';
        }).filter((tag) => tag !== '');
    }
    else if (typescript_1.default.isStringLiteral(firstArg)) {
        nodeTags = [firstArg.text];
    }
    else {
        return {
            node,
            tags: parentTags,
            skipNode: false,
        };
    }
    // Create unique list of tags from current node and parents
    const uniqueTags = [...new Set([...nodeTags, ...parentTags])];
    const skipNode = calculateSkipChildren(includeTags, excludeTags, uniqueTags);
    // Create a new node removing the tag list as the first argument
    const newArgs = typescript_1.factory.createNodeArray([...node.arguments.slice(1)]);
    const newExpression = typescript_1.factory.createCallExpression(node.expression, undefined, newArgs);
    return {
        node: newExpression,
        tags: uniqueTags,
        skipNode,
    };
};
// Transform TypeScript AST to filter tests and remove tag arguments to make compatible with Cypress types
const transformer = (config) => (context) => (rootNode) => {
    const { includeTags, excludeTags } = extractTags(config);
    const visit = (node, parentTags) => {
        let tags = parentTags !== null && parentTags !== void 0 ? parentTags : [];
        let returnNode = node;
        let skipNode = false;
        if (typescript_1.default.isCallExpression(node)) {
            const firstArg = node.arguments[0];
            const secondArg = node.arguments[1];
            const firstArgIsTag = firstArg && typescript_1.default.isStringLiteral(firstArg) && isTitle(secondArg);
            if (typescript_1.default.isIdentifier(node.expression)) {
                if (isDescribe(node) || isContext(node)) {
                    // Describe / Context block
                    if (firstArgIsTag || typescript_1.default.isArrayLiteralExpression(firstArg)) {
                        // First arg is single tag or tags list
                        const result = removeTagsFromNode(node, tags, includeTags, excludeTags);
                        skipNode = result.skipNode;
                        returnNode = result.node;
                        tags = result.tags;
                    }
                }
                else if (isIt(node)) {
                    // It block
                    if (firstArgIsTag || typescript_1.default.isArrayLiteralExpression(firstArg)) {
                        // First arg is single tag or tags list
                        const result = removeTagsFromNode(node, tags, includeTags, excludeTags);
                        skipNode = result.skipNode;
                        returnNode = result.node;
                    }
                    else if (isTitle(firstArg)) {
                        // First arg is title
                        skipNode = calculateSkipChildren(includeTags, excludeTags, tags);
                    }
                }
            }
            else if (typescript_1.default.isPropertyAccessExpression(node.expression)) {
                // Extra check in case property access expression is from a forEach or similar
                if (isSkip(node.expression) || isOnly(node.expression)) {
                    // Node contains a .skip or .only
                    if (isIt(node.expression)) {
                        // It block
                        if (firstArgIsTag || typescript_1.default.isArrayLiteralExpression(firstArg)) {
                            // First arg is single tag or tags list
                            const result = removeTagsFromNode(node, tags, includeTags, excludeTags);
                            skipNode = result.skipNode;
                            returnNode = result.node;
                        }
                    }
                }
            }
        }
        if (skipNode) {
            // Replaces node with semi-colon, effectively skipping node and any children
            returnNode = typescript_1.factory.createEmptyStatement();
        }
        else {
            returnNode = typescript_1.default.visitEachChild(returnNode, (node) => visit(node, tags), context);
        }
        return returnNode;
    };
    return typescript_1.default.visitNode(rootNode, visit);
};
const processFile = (fileName, source, config) => {
    const printer = typescript_1.default.createPrinter();
    const sourceFile = typescript_1.default.createSourceFile(fileName, source, typescript_1.default.ScriptTarget.Latest, true, typescript_1.default.ScriptKind.TS);
    const transformedResult = typescript_1.default.transform(sourceFile, [transformer(config)]);
    const transformedSourceFile = transformedResult.transformed[0];
    const result = printer.printFile(transformedSourceFile);
    return result;
};
const transform = (fileName, config) => {
    let data = '';
    function ondata(d) {
        data += d;
    }
    function onend() {
        this.queue(processFile(fileName, data, config));
        this.emit('end');
    }
    if (/\.json$/.test(fileName)) {
        return through_1.default();
    }
    return through_1.default(ondata, onend);
};
const preprocessor = (config) => {
    const options = Object.assign(Object.assign({}, browserify_preprocessor_1.default.defaultOptions), { typescript: require.resolve('typescript'), browserifyOptions: Object.assign(Object.assign({}, browserify_preprocessor_1.default.defaultOptions.browserifyOptions), { extensions: ['.ts'], transform: [
                ...browserify_preprocessor_1.default.defaultOptions.browserifyOptions.transform,
                (fileName) => transform(fileName, config),
            ] }) });
    return browserify_preprocessor_1.default(options);
};
preprocessor.transform = transform;
module.exports = preprocessor;
